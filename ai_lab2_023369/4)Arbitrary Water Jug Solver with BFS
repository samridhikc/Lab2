import math
from collections import deque

class WaterJugAI:
    def __init__(self, capacity1, capacity2, target):
        self.c1 = capacity1
        self.c2 = capacity2
        self.target = target
        self.visited = set()

    def goal_test(self, state):
        """
        Verifies the state description: 
        Does either jug contain the exact target volume?
        """
        j1, j2 = state
        return j1 == self.target or j2 == self.target

    def get_successors(self, state):
        """Generates all valid next states from the current volume."""
        j1, j2 = state
        successors = [
            ((self.c1, j2), "Fill Jug 1"),
            ((j1, self.c2), "Fill Jug 2"),
            ((0, j2), "Empty Jug 1"),
            ((j1, 0), "Empty Jug 2"),
            # Pour Jug 1 -> Jug 2
            ((max(0, j1 - (self.c2 - j2)), min(self.c2, j1 + j2)), "Pour J1 -> J2"),
            # Pour Jug 2 -> Jug 1
            ((min(self.c1, j1 + j2), max(0, j2 - (self.c1 - j1))), "Pour J2 -> J1")
        ]
        return successors

    def solve(self):
        # BFS Queue: (current_state, path_of_actions)
        queue = deque([((0, 0), [])])
        self.visited.add((0, 0))

        # Mathematical impossibility check
        if self.target > max(self.c1, self.c2) or self.target % math.gcd(self.c1, self.c2) != 0:
            return None

        while queue:
            (curr_j1, curr_j2), path = queue.popleft()

            if self.goal_test((curr_j1, curr_j2)):
                return path + [(f"GOAL REACHED: ({curr_j1}, {curr_j2})")]

            for next_state, action in self.get_successors((curr_j1, curr_j2)):
                if next_state not in self.visited:
                    self.visited.add(next_state)
                    new_path = path + [f"{action} -> ({next_state[0]}, {next_state[1]})"]
                    queue.append((next_state, new_path))
        
        return None

# --- Execution ---
def main():
    print("=== AI Water Jug Solver (BFS) ===")
    try:
        cap1 = int(input("Enter Capacity of Jug 1: "))
        cap2 = int(input("Enter Capacity of Jug 2: "))
        target = int(input("Enter Target Volume: "))

        agent = WaterJugAI(cap1, cap2, target)
        solution = agent.solve()

        if solution:
            print(f"\nSolution Found in {len(solution) - 1} steps:")
            print("Start: (0, 0)")
            for step in solution:
                print(step)
        else:
            print("\nNo solution possible for these inputs.")
            
    except ValueError:
        print("Invalid input. Please enter integers only.")

if __name__ == "__main__":
    main()
